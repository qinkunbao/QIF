\documentclass[conference]{IEEEtran}

\usepackage{listings}
\usepackage{epsfig}
\usepackage{url}
\usepackage{cite}
\usepackage{fancybox}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{multirow}
\usepackage{balance}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{subfig}
\usepackage[ruled,linesnumbered]{algorithm2e}

\usepackage[scaled]{beramono}
\usepackage[T1]{fontenc}

\usepackage[english]{babel} % handle hyphenation

\lstset{
numbers=left,
frame=single,
language=C,
basicstyle=\fontfamily{fvm}\scriptsize,
showlines=true
%xleftmargin=.2\textwidth, xrightmargin=.2\textwidth,
}

\newcommand{\highlight}[1]{\colorbox{yellow}{\textbf{#1}}}
\newcommand{\fixme}[1]{\highlight{FIXME:} \emph{#1}}
\newcommand{\todo}[1]{\highlight{TODO:} \emph{#1}}
\newcommand{\Qinkun}[1]{\highlight{Qinkun's Response:} \emph{#1}}

\newcommand{\tool}{TANA}
\renewcommand{\tool}{CleverHans}
\newcommand{\tana}{\tool}

\begin{document}

\title{\tool{}: Precise Fine-grained Side-channel Information Leakage Quantification in Binaries}
\author{Anonymous}

\maketitle

\begin{abstract}
Side-channel attacks allow adversaries to infer sensitive information
based on non-functional characteristics.  Existing work on
address-based side-channel detections can identify many tentative
side-channel leakage sites.
  %Those leakage sites can leak one bit, two bits, or many bits.
However, no existing tools can precisely report the number of leaked
bits for each leakage site, for production systems.
       
To overcome the limitation, we propose a novel method to precisely
quantify the leaked information from side-channel vulnerabilities.  We
model each leakage as a constraint and use those constraints to
divide the input space set into several subsets such that  %.  Among those subsets,
only one subset satisfies every constraint.  %As we discuss later,
The cardinality of the subset corresponds to the amount of leaked
information from those leakages.
We use symbolic executions to
generate math constraints. It is widely believed that symbolic
execution is expensive in terms of performance. We systematically
analyze the bottlenecks of the current dynamic symbolic execution
approach and make it scalable to real-world cryptosystems. In the
final step, we run Monte Carlo sampling to estimate the number of
leaked information for each detected vulnerabilities. With the help of
the Central Limit Theorem (CLT), we can also give the error
estimation.

    We have implemented the above technique in a tool called \tool{}, which can not only find the side-channel vulnerabilities but also estimate how many bits are leaked. 
    \tool{} outperforms existing dynamic side-channel detection tools in terms of performance and accuracy. Also, \tool{} can report a very fined-grained vulnerability leakage information.
    Compared to existing abstract interpretation approaches that can only give upper leakage
    bounds, those information are more useful for developers to identify the severity level
    of each side-channel vulnerabilities.
    
    We apply \tool{} on OpenSSL, MbedTLS, and found several side-channel severe vulnerabilities. Compared with previous research, the results are surprisingly different. 
    First, it shows that most of the reported vulnerabilities are hard to exploit in practice. 
    Second, we also find several sensitive vulnerabilities that are neglected before \tool{}. 
    We confirmed those vulnerabilities with manual checks and software developers.
    %% which are confirmed with manual checks and software developpers. 

\end{abstract}


\IEEEpeerreviewmaketitle
\pagenumbering{arabic}
\pagestyle{plain}

\input{sections/introduction}
\input{sections/background}
\input{sections/threat_model}
\input{sections/trace_qif}
\input{sections/challenge}
\input{sections/design}
\input{sections/implementation}
\input{sections/evaluation}
\input{sections/discussion}
\input{sections/related_work}
\input{sections/conclusion}

\bibliographystyle{IEEEtran}
\bibliography{refs}

\end{document}


