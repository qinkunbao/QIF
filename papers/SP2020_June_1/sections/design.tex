\section{Design}
In this section, we will explain the design decisions to realize A. 

Binary code vs source code:

Many existing works find side-channels vulnerabilities from source code level or intermediate languages (e.g., LLVM IR). Those approaches will have the following questions. First, many compilers can translate the operator into branches. For example, the GCC compiler will translate the ! operator into conditional branches. If the branch is secret-dependent, the attacker could learn some sensitive information. But those source-based methods will fail to detect those vulnerabilities. Second, some if else in the source code can be converted into single conditional instructions (e.g., cmov). Source-based methods will still regard them as potential leakages, which will introduce false positives.

Intermediate Language vs X86 


The tool takes in an unmodified binary and the marked sensitive information as the input. The tool will first start with logging the execution trace. Then the tool will symbolizes the sensitive information into multiple symbols and start with the symbolic execution. During the symbolic execution, the tool will find any potentials leakage sites as well as the path constraints. For each leakage site, whether it is  the tool will also generate the constraint. Then, the tool will split the constraints into multiple group. After that, the tool will run monte carlo sampling to estimate the total information leakages.

\subsection{Trace Logging}
The trace information can be logged via some emulators (e.g., QEMU) or Binary Instrumentation Tools. For our project, we write an Intel Pin Tool to record the execution traces. The trace data has the following information:
Each instruction mnemonics and its memory address
The operands of each instruction and their values
The memory address of sensitive information and its length
The value of eflags register
Most software developers stores sensitive information in an array, a variable or a buffer, which means that those data is stored in a contiguous area in the memory. We use the symbol information in the binary to track the address in the memory.

\subsection{Instruction Level Symbolic Execution}
The main purpose of the this step is to generate constraints of the input sensitive information for the execution trace. If we give the target program a new input which is different from the origin input that was used to generate the execution trace but still satisfies those constraints, the new execution trace will still have the same control flow and data access patterns. 

The tool runs the symbolic execution on the top of the execution traces. At the beginning of the symbolic execution, the tool creates fresh symbols for each byte in the sensitive buffer. For other data in the register or memory at the beginning of the symbolic execution, we use the concrete value from the runtime information collected in the previous step. During the symbolic execution, the tool will maintain a symbol and a concrete value for every variables in the memory and registers. The formula is made up with concrete values and the input key as the symbols calculated through the symbolic execution. For each formula, the tool will check weather it can be reduced into a concrete values. If so, the tool will only use the concrete values in the following symbolic execution.

\subsection{Verification and Optimizayion}
We run the symbolic execution on the top of x86 instructions to achieve the better performance and accuracy of the memory model. In other words, we don’t rely on any intermediate languages to simplify the symbolic execution. While the implementation itself has a lot of benefits, we need to implement the symbolic execution rules for more than one thousand x86 instructions. However, due to the complexity of X86, it is inevitable to make mistakes. Therefore, we verify the correctness of the symbolic execution. The tool will collect the runtime information (Register values, memory values) and compare them with the values generated from the symbolic execution. Whenever the tool finishes the symbolic execution of each instruction, the tool will compare the formula for each symbol and its actual value. If the two values don’t match, we check the code and fix the error. Also, if the formula doesn’t contain the any symbols, the tool will use the concrete value instead of symbolic execution.

\subsection{Secret-dependent control-flows}
An adversary can infer sensitive information from secret dependent control-flows. 
There are two kinds of control-transfer instructions: the unconditional control transfer instructions and the conditional transfer instructions. The unconditional instructions, like CALL, JUMP, RET transfer control from one code segment location to another. Since the transfer is independent from the input sensitive information, an attacker was not able to infer any sensitive information from the control-flow. So the unconditional control transfer doesn’t leak any information based on our threat model. During the symbolic execution, we just update the register information and memory cells with the new formulas.

The conditional transfer instructions, like conditional jump, may or may not transfer control, depending the CPU state. For any conditional jump, the CPU will test if certain condition flag (e.g., CF = 0, ZF =1) is true or false and jump to the certain branches respectively. So the symbolic engine will compute the flag and represent the flag in a symbol formula. Because we are running on a symbolic execution on a execution trace, we know which branch executes. If a conditional jump uses the CPU status flag, we will generate the constraint accordingly.

For examples,

\begin{lstlisting}
...
0x0000e781      add dword [local_14h], 1
0x0000e785      cmp dword [local_14h], 4
0x0000e789      jne 0xe7df
0x0000e78b      mov dword [local_14h], 0

\end{lstlisting}

At the beginning of the instruction segment, the value at the address of local14h can be written as F(K). At the address e785, the value will be updated with F(K)+1. Then the code compare the value with 4 and use the result as a conditional jump. Based on the result, we can have the following constrain:

F(K) + 1 = 4
 
\subsection{Secret-dependent data access}
Like control-flows, an adversary can also infer sensitive information from the data access pattern as well. We try to find this kind of leakages by checking every memory operand of the instruction. We generate the memory addressing formula. As discussed before, every symbols in the formula is the input key. If the formula doesn’t contain any symbols, the memory access is independent from the input sensitive information and won’t leak any sensitive information according to our threat model. Otherwise, we will generate the constraint for the memory addressing. 


Monte Carlo Volume Sampling
From the above steps, we already have the constraints from the execution trace. The only variables in those constraints is the sensitive data. An adversary who wants to infer the sensitive data based on side-channel attacks can’t observe the sensitive information directly. The adversary, however, can observe the memory access pattern of the software.  

We use the Monte Carlo Sampling to calculate the ratio of input that satisfies those constraints.
We will estimate how much information is actually leaked from each input key.

Normalizations
The goal of the normalizations is to simplify the constraints. Each constraint will be evaluated multiple times during the following sampling, we would like to make those formula simpler to reduce the whole execution time.  Each formula is implemented as a abstract syntax tree. We apply a series normalization rules (e.g. key1 xor key1 = 0) to simplify the formula.


Key1 + 1 + 2 + key3 < key2 => key1 + 3 < key2

Split the independent constraints into multiple groups
Each constraints may have multiple symbols as the input. If each two formulas have complete different inputs, then those leakages modeled by the constraints are independent. 

Multiple Stage Monte Carlo Sampling
