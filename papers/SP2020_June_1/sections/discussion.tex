\section{Discussion on implementation}

\subsection{Binary code vs source code}
Many existing works find side-channels vulnerabilities from source code level 
or intermediate languages (e.g., LLVM IR). Those approaches will have the following questions. 
First, many compilers can translate the operator into branches. For example, 
the GCC compiler will translate the ! operator into conditional branches. 
If the branch is secret-dependent, the attacker could learn some sensitive information.
But those source-based methods will fail to detect those vulnerabilities. 
Second, some if else in the source code can be converted into single conditional 
instructions (e.g., cmov). Source-based methods will still regard them as potential leakages, 
which will introduce false positives.

\subsection{X86 vs Intermediate Languages}
The tool takes in an unmodified binary and the marked sensitive information as the input. 
The tool will first start with logging the execution trace. Then the tool will symbolizes the 
sensitive information into multiple symbols and start with the symbolic execution. 
During the symbolic execution, the tool will find any potentials leakage sites as well as the path constraints. 
For each leakage site, whether it is  the tool will also generate the constraint. 
Then, the tool will split the constraints into multiple group. After that, 
the tool will run monte carlo sampling to estimate the total information leakages.
