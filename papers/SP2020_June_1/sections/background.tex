\section{Background}
In this section, we first present a basic introduction about the 
several kinds of memory-based side-channel attack. Those attacks 
are exactly what we attempt to study in the paper. Then we present
existing work on side-channel detection and quantification.  
\subsection{Address-based Side-Channels}
Address-based side-channels are information channels that can leak sensitive information unintended
through the different behaviors when the program accesses different memory addrsss. Fundamentally,
those difrences were caused by the memory hierarchy design in modern computer systems. When the 
CPU fetches the data, it will first search the cache, which stores copies of the data from 
the frequently used main memory. If the data doesn't exist in the cache, the CPU will read
the data from the main memory (RAM). Classified by the layer caused the side-channel, we 
introduce two kinds of commom side-channels: cache-based side-channel attacks and memory-based
side-channel attacks.

\subsubsection{Cache-based Attack}
In general, the cached-based side-channel attacks seek information 
rely on the time differences between the cache miss
and cache hit. Here we introduce two types of cache attacks:
PRIME+PROBE, FLUSH+RELOAD.

\textbf{PRIME+PROBE} targets a single cache set. It has two phases. During the
"prime" phase, the attacker fills the cache set will his own data.
In the second "probe" phase, the attacker accesses the cache set
again. If the victim accesses the cache set and evicts part of 
the data, the attacker will experience a slow mesurement. If not, 
the mesurement will be fast.

\textbf{FLUSH+RELOAD}targets a single cache line. 
It requires the attacker and victim share the same memory.
It also have two phases. During the "flush" phase, the attacker 
will flush the "monitered memory" from the cache. Then the attacker
wait for the victim to access the memory. In the third phase, the 
attacker reload the "monitered memory". If the time is short, which
indicates there is a cache hit and the victim reolads the memory before. 
On the other hand, the time will be longer since the CPU need to reolad
the memory into the cache line. 

\subsubsection{Memory-based Attack}
Memory-based side-channel attack\cite{} exploits the different behaviors when the
program accesses different page tables. The controlled-channel attack\cite{7163052},
works in the kernel space can infer the sensitive data in the shielding systems by
observing the page fault sequences by restricting some code and
data pages. 

After examing the memory-based side-channels attack. We find the fundamentally
reason of those attacks are due to secret-dependent memory access and control
flow transfers.
\lstinputlisting[language=c, 
                 numbers=right,
                 caption={Sample code shows secret-dependent memory access and 
                          secret-dependent control-flow transfer.},
                 captionpos=b,
                 label={code:background},
                 basicstyle=\fontsize{7}{9}\selectfont\ttfamily]
                 {sample_code/background.c}

For exampls, the above code~\ref{code:background} show an simpple encrypt function that
has the two kinds of side-channels. At the line 11, dependending on the value of key,
the code will access the different entry in the predefined table /textbf{Table}. At the
line 13, the code will do a series of computation and determine if the code in the if
branch is executed or not. Such vulnerabilities could leak to the memory-based 
side-channles. We indentify and quanify the leakage of the two kinds of vulnerabilities 
in the paper.

\subsection{Information Leakage Quantification}
Given an event E which occurs with the probability $P(E)$, if the event E happens, 
then we receive
\begin{equation}
    I = - log(P(E))
\end{equation}
bits of information.

The above definition is obvious. Suppose a char variable \textit{a} in C program has 
byte (8 bits) size, so the value in the variable can range from 0 - 255. We assume
the \textit{a} has the uniform distribution. If at one time we observe the \textit{a}
equals to 1, the probability will be 1/256. So the information we get is 
$-log(1/256) = 8 bits$, which is exactly the size of the char variable.

One method to quanify the prgoram is based on the channel capacity theorem. It shows
that the max leakage of the program equals to the log of the number of possible
distinct observations (NumOfObs) that an attacker can make.
\begin{equation}
    Leakageed Information <= - log(NumOfObs)
\end{equation}