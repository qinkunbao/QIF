\section{Background and Threat Model}
In this section, we first present an introduction to software-based 
side-channel attacks. Moreover, we analyze the root cause of many
software-based side-channels. We find many of them are caused by
two specific side-channel vulnerabilities, secret-dependent control-flow transfers and
secret-dependent memory accesses. Therefore, we will focus on identifying
and quantifying those leakages in the paper. After that, we 
discuss existing methods on side-channel detection and quantification.

\subsection{Software-based Side-channels}
Side-channels are information channels that can leak sensitive information 
unconsciously through different execution behaviors.  Fundamentally, those 
differences were caused by shared hardware
components (e.g., the CPU cache, the TLB and DRAM) in modern computer systems.
Depending on the layer causing side-channels, we can classify them 
into the following types of side-channel attacks.

For example, cached-based side-channels rely on the time differences 
between cache miss and cache hit. We introduce two common attack strategies,
namely Prime+Probe and Flush+Reload.
Prime+Probe targets a single cache set. The attacker preloads cache set with
its own data and wait until the victim execute the program.
If the victim accesses the cache set and evicts part of 
the data, the attacker will experience a slow measurement. If not, 
it will be fast. By knowing which cache set the target
program accesses, the attacker can infer locations of
the sensitive information. Flush+Reload targets a single cache line. 
It requires the attacker and the victim share the same memory address space.
During the ``flush'' stage, an attacker 
flushes the ``monitored memory'' from the cache. Then the attacker
waits for the victim to access the memory. In the next phase, the 
attacker reload the ``monitored memory''. By measuring the time difference, the
attacker can infer the sensitive information.

There are some other types of side-channels which target different hardware layers other than  
CPU cache as well.
For example, the controlled-channel attack~\cite{7163052},
where an attacker works in the kernel space, can infer sensitive data in the shielding systems by
observing the page fault sequences after restricting some code and
data pages. 

\begin{figure}[]

\noindent\begin{minipage}{0.45\linewidth}
    \noindent
\begin{lstlisting}[numbers = none]
unsigned long long r;
int secret[32];
while(i>0){
    r = (r * r) % n;
    if(secret[--i] == 1){
        r = (r * x) % n;
    }
}
\end{lstlisting}
\caption{Secret-dependent control-flow transfers}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[numbers = none]
static char Fsb[256] = {...}
... 
uint32_t a = *RK++ ^ \ 
(FSb[(secret)) ^
(FSb[(secret >> 8)] <<  8 ) ^
(FSb[(secret >>16)] << 16 ) ^
(FSb[(secret >>24)] << 24 );
...
\end{lstlisting}
\caption{Secret-dependent memory accesses}
\end{minipage}
\end{figure}

The key intuition is that each side-channels above happens when the program accesses different 
memory addresses if the program has different sensitive inputs. More specifically, if 
a program show different patterns in control transfers or data accesses when the program 
processes different sensitive inputs, the program could possibly have side channels vulnerabilities. 
Different kinds of side-channels can be exploited to retrieve information
in various granularities. For example, many cache channels can observe cache accesses
at the level of a cache line. For most CPU, one cache line holds 64 bytes of data. So
the low 6 bits the address is irrelevant in causing those cached-based side-channels. 

%\lstinputlisting[language=c, 
%                 numbers=left,
%                 caption={Sample code shows secret-dependent memory access and 
%                          secret-dependent control-flow transfer.},
%                 captionpos=b,
%                 label={code:background},
%                 frame=single,
%                 basicstyle=\fontsize{7}{9}\selectfont\ttfamily]
%                 {sample_code/background.c}

%For example, the above code~\ref{code:background} show a simple encryption function that
%has the two kinds of side-channels. At line 11, depending on the value of a key,
%the code will access the different entry in the predefined table. At the
%line 13, the code will do a series of computation and determine if the code in the if
%branch is executed or not. Such vulnerabilities are called the memory-based 
%side-channles. We identify and quantify the leakage of the two kinds of vulnerabilities 
%in the paper.

\subsection{Threat Model}
We consider an attacker who shares the same hardware resource with the victim. 
The attacker attempts to retrieve sensitive information via memory-based 
side-channel attacks. 
The attacker has no direct access to the memory or cache but can probe the 
memory or cache at each program point. In reality, the attacker will face 
many possible obstacles,
including the noisy observations, limited observations on memory or cache.
However, for this project, we assume the attacker can have noise-free observations. 
The threat model captures most of the cache-based and memory-based side-channel attacks.
We only consider the deterministic program for the project.