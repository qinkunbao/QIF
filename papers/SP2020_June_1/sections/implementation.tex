\section{Implementation}
We implement the \tool{} with 14320 lines of code in C++11. 
It has three components, Intel
Pin tool that can collect the execution trace, 
the instruction-level symbolic execution
engine, and the backend that can estimate the information leakage. 
The tool can also report the memory address of the leakage site. 
To assist the developers fix the bugs,
we also have several Python scripts that can report the leakage 
location in the source code with the debug information and the symbol 
information. A sample report can be found at the appendix.

\begin{table}[h]
    \centering
    \resizebox{.8\columnwidth}{!}{
    \begin{tabular}{ll}
    \hline
    Component                            & Lines of code (LOC)    \\ \hline
    Trace Logging                        & 101 LOC of C++   \\ 
    Symbolic Execution & 11547 LoC of C++ \\ 
    Data Flow & 451 LoC of C++                      \\
    Monte Carlo Sampling                 & 603 LOC of C++   \\ 
    Others                               & \fixme{xxx} LOC of Python    \\ \hline
    Total    & \fixme{xxx} LOC \\\hline
    \end{tabular}
    }
    \caption{\tool{}'s main components and their LoC}
\end{table}

Our current implementation supports part of the Intel 32-bit instructions, 
including bitwise operations, control transfer, data movement, and logic 
instructions which are essential in finding memory-based side-channel 
vulnerabilities. For other 
instructions the current implementation does not support, 
the tool will use the real values to update the registers and memory cell.
Therefore, the tool may miss some leakages but will not give us any new
false positives with the implementation.
