\section{Evaluation}
\label{res_overview}

\begin{table*}
    \centering
    \caption{Result}
    \label{fig:Test}
    \begin{tabular}{rrrrrrrrr}
      \hline
Algorithm & Implementation & \# of Lekage Sites & \# of CF & \# of DF & Total Instructions & Max Leakeage (bits) & Symbolic Execution Time & Monte Carlo Time\\\hline
AES & mbed TLS 2.5   & 68 & 0 & 68 & 39,855 & 8 & 570ms & 850ms\\
AES & mbed TLS 2.15  & 68 & 0 & 68 & 39,855 & 8 & 550ms & 829ms\\
AES & openssl 0.9.7  & 75 & 0 & 75 & 1,704 & 10 & 319ms & 7s 720ms\\
AES & openssl 1.0.2f & 88 & 0 & 88 & 1,350 & 12 & 72ms & 1s 500ms\\
AES & openssl 1.0.2k & 88 & 0 & 88 & 1,350 & 11 & 83ms & 1s 441ms\\
AES & openssl 1.1.0f & 88 & 0 & 88 & 1,420 & 12 & 87ms & 1s 454ms\\
AES & openssl 1.1.1  & 88 & 0 & 88 & 1,586 & 8 & 91ms & 1s 250ms\\
DES & mbed TLS 2.5   & 15 & 0 & 15 & 4,596 & 1 & 114ms & 144ms\\
DES & mbed TLS 2.15  & 15 & 0 & 15 & 4,596 & 1 & 106ms & 137ms\\
DES & openssl 0.9.7  & 6 & 0 & 6 & 2,976 & 7 & 149ms & 4s 193ms       \\
DES & openssl 1.0.2f & 8 & 0 & 8 & 2,593 & 9 & 239ms & 5s 311ms       \\
DES & openssl 1.0.2k & 8 & 0 & 8 & 2,593 & 9 & 235ms & 5s 80ms        \\
DES & openssl 1.1.0f & 8 & 0 & 8 & 4,260 & 9 & 256ms & 5s 27ms        \\
DES & openssl 1.1.1  & 6 & 0 & 6 & 8,272 & 7 & 235ms & 4s 584ms       \\
RSA & mbed TLS 2.5   & 6 & 6 & 0 & 22,109,246 & 9      & 37m 51s & 20m 10s \\
RSA & mbed TLS 2.15  & 12 & 0 & 12 & 24,484,441 & 9    & 39m 17s & 4h 1m 16s     \\
RSA & openssl 0.9.7  & 105 & 103 & 2 & 16,980,109 & 13 & 28m 26s & 4h 26m 33s \\
RSA & openssl 1.0.2f & 38 & 27 & 11 & 14,468,307 & 10  & 28m 11s & 2h 40m 17s  \\
RSA & openssl 1.0.2k & 36 & 27 & 9 & 15,285,210 & 12   & 39m 13s & 4h 42m 43s   \\
RSA & openssl 1.1.0f & 31 & 22 & 9 & 16,390,750 & 13   & 32m 48s & 4h 21m 58s   \\
RSA & openssl 1.1.1  & 26 & 20 & 6 & 18,207,020 & 12   &  7m  3s & 7h 35m         \\\hline
\end{tabular}
\end{table*}

We evaluate \tool{} with the real-world crypto libraries and non-crypto libraries. 
For crypto libraries, we choose OpenSSL, mbedTLS and NaCl. 
OpenSSL and mbedTLS are the two most commonly used
crypto libraries in today's software. NaCl (pronounced "salt") is a 
new software libreary for encryption, decryption and signatures, etc.
NaCl is designed to have no data flow from secrets to load address and no data 
flow from secrets to branch conditions. Therefore, NaCl should have no leakages
under our attack model. 

For non-crypto libraries, we study libjepg, GTK, and wget.
JPEG is a commonly used lossy image c ompression standard, and
libjpeg is a popular library for handling the JPEG image data
format. Previously, researchers have introduced controlled-channel
attacks, which allow attackers to ret rieve outlines of JPEG images
from applications. We also study GTK and wget with \tool{}. GTK 
is a widely used cross-platform toolkit for creating graphical user
interfaces. And wget is free software that can retrieve information
via HTTPS, HTTP, and FTP.

We build the source code into 32-bit x86 Linux executables with the 
GCC 8.0 on Ubuntu 14.04. Although our tool can
work on stripped binaries, we use symbol information to track
back leakage sites in the source code. We use Intel Pin version 3.7 
to record the execution trace. We run our experiments on a 2.90GHz
Intel Xeon(R) E5-2690 CPU with 128GB memory.
During the evaluation, we are interested in the following two
aspects:
\begin{enumerate}
    
    \item  Can \tool{} precisely
    report the number of leaked bits in open source libraries?
    \item  Recent work has reported a number
    of side-channel vulnerabilities in open source libraries. 
    Is the number of leaked bits reported by \tool{} useful to justify 
    the sensitive level of side-channel vulnerabilities?
   
\end{enumerate}

\subsection{Evaluation Result Overview}
In this section, we present an overview of the evaluation result. 
\tool{} find xx leakages in total from real-world cryptosystems source libraries.
 Among the xx leak points, xx of them are leaked due
to secret-dependent control-flow transfers and xx of them are leaked 
due to secret-dependent memory accesses. 

For crypto libraries, \tool{} finds that secret-dependent memory accesses 
cause most leakages. 
\tool{} also identifies that most side-channel vulnerabilities 
leak very little information in practice, which confirms our initial
assumptions. 
However, we do find some sensitive leakages. 
Some of them have been confirmed by existing research that those 
vulnerabilities can be exploited to realize real attacks. 

All the symmetric key implementations in OpenSSL and mbedTLS all yield
significant leakages due to the implementation of the lookup table
to speed up the computation. Every leakages found during the evaluation
belongs to the type of secret-dependent memory accesses. We believe that
the secret-dependent control-flow transfers have been widely studied in
the past few years, and developers have patched most of those leakages. 
One method to address the leakage is to use bit-slicing. We will analyse
the corresponding countermeasure in the following sections.

\tool{} find several leakage sites for the implementation of DES in OpenSSL.
Each leakage can leak one bit of information from one byte. Also, our tool
confirms those leakages are independent, so the total leaked information leakage
is 8 bits. We check the source code and find the least significant
bit in each byte is used for the parity. Therefore, \tool{} can confirm
that even the key length of DES is 64 bits. However, only 56 bits of the 
DES key is valid. 



\subsection{Information Leakage Quantification}
\subsection{Analysis of Software Countermeasures}
\subsubsection{Bit-slicing}
\subsubsection{Scatter and Gather}
\subsection{Case Studies}
\subsubsection{libjpeg}

