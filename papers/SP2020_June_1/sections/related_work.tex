\section{Related Work}

There is vast amount of work on side channel attacks, detection,
quantification, and mitigation. Here we only present the closely
related work to ours.

\subsection{Attacks}

\subsection{Detection}

There are a large number of works on side-channel vulnerability
detections in recent years.  CacheAudit~\cite{182946} uses abstract
domains to compute the over approximation of cache-based side-channel
information leakage upper bound. However, due to over approximation,
the leakage given by CacheAudit can indicate the program is
side-channel free if the program has zero leakage.  However, it is
less useful to judge the sensitive level of the side-channel leakage
based on the leakage provided by CacheAudit. CacheS~\cite{236338}
improves the work of CacheAudit by proposing the novel abstract
domains, which only track secret-related code. Like CacheAudit, CacheS
can not provide the information to indicate the sensitive level of
side-channel vulnerabilities.

The dynamic approach, usually comes with taint analysis and symbolic
execution, can perform a very precise analysis. CacheD~\cite{203878}
takes a concrete program execution trace and run the symbolic
execution on the top of the trace to get the formula of each memory
address. During the symbolic execution, every value except the
sensitive key uses the concrete value. Therefore, CacheD is quite
precise in term of false positives. We adopted a similar idea to model
the secret-dependent memory accesses. DATA~\cite{217537} detects
address-based side-channel vulnerabilities by comparing different
execution traces under various test
inputs. MicroWalk~\cite{Wichelmann:2018:MFF:3274694.3274741} uses
mutual information (MI) between sensitive input and execution state to
detect side-channels. They can only detect control-flow channels and
MI scores are less meaningful for dynamic analysis.

\subsection{Quantification}

Quantitative Information Flow (QIF) aims at providing an information
leakage estimate for the sensitive information given the public
output. If zero bits of the information is leaked, the program is
called non-interference. McCamant and Ernst~\cite{McCamantE2008} quantify the
information leakage as the network flow
capacity. Phan et al.~\cite{Phan:2012:SQI:2382756.2382791} propose symbolic
QIF. The goal of their work is to ensure the program is
non-interference. They adopt an over approximation way of estimating
the total information leakage and their method doesn't work for
secret-dependent memory access
side-channels. CHALICE~\cite{Chattopadhyay:2017:QIL:3127041.3127044}
quantifies the information for a given cache behaviours. But CHALICE
can only work on PICA code (a MIPS like architecture), which limits
its usage on x86 bianry.  CHALICE can only scale to small programs,
which limits its usage in real-world applications.

\subsection{Mitigation}
